;; OK - note use of unwind-protect.;; without it, an error could end without saving file(defun make-workspace (filename)    (catch 'stop    (format t "Starting workspace.  End with (save-ws) ~%")    (let ((stream (open filename :direction :output))                  (ws-prompt "WS> "))          (flet ((ws-fn? (input)                                         (cond ((eq (car input) 'save-ws)                                                        (close stream)                                                        (throw 'stop nil)))))                (format stream ";; workspace file ~%")                (unwind-protect                        (loop                          (format t "~%~A" ws-prompt)                         (let ((input (read *standard-input*)))                           (cond ((listp input)                                          (ws-fn? input)                                          (format stream "~%~A" input)))                           (print (eval input) *standard-output*)))                  (close stream)))))                         (format t "~%Workspace saved in file: ~A~%" filename)  'end-workspace)(defun cl-eval (exp env)      (cond ((or (numberp exp)               (characterp exp)               (stringp exp))           exp)          ((symbolp exp)           (value env exp))          ((consp exp)           (case (car exp)            ((quote)    (cadr exp))            ((if)       (cl-eval-if       exp env))            ((block)    (cl-eval-block    exp env));;            ((locale)   (cl-eval-locale   exp env))            ((lambda)   (cl-eval-lambda   exp env))            ((defun)    (cl-eval-define   exp env))            ((lset)     (cl-eval-lset     exp env))            ((set)      (cl-eval-set      exp env))ll            ((object)   (cl-eval-object   exp env))            ((case)     (cl-eval-case     exp env))            ((cond)     (cl-eval-cond     exp env))            ((and)      (cl-eval-and      exp env))            ((or)       (cl-eval-or       exp env))            ((let)      (cl-eval-let      exp env))            (else       (cl-eval-call     exp env))))))(defun cl-eval-call (exp env)   (apply #'(cl-eval (car exp) env)         (mapcar #'(lambda (arg) (cl-eval arg env))                 (cdr exp))))(defun cl-eval-if (exp env)  (if (cl-eval (cadr exp) env)      (cl-eval (caddr exp) env)    (cl-eval (cadddr exp) env)))(defun cl-eval-block (exp env)   (cl-eval-sequence (cdr exp) env))(defun cl-eval-sequence (exps env)   (cond ((NULL (cdr exps))         (cl-eval (car exps) env))        (else         (cl-eval (car exps) env)         (cl-eval-sequence (cdr exps) env))))(define-method (cl-env-lookup self id local? create?)  (env-lookup self id local? create?))(defun cl-eval-locale (exp env)  (let ((the-env nil))    (setf the-env          (object nil                  ((cl-env-lookup self id local? create?)                   (cond ((and local? (not create?))                          nil)                         ((and (not local?)                               (cl-env-lookup env id nil nil)))                         (create?                          (SETF the-env                                (bind-variable id (undefined-value)                                               the-env))                          (cl-env-lookup the-env id local? create?))                         (else nil)))))    (let ((the-locale           (object nil                   ((cl-env-lookup self id local? create?)                    (cl-env-lookup the-env id local? create?)))))      (if (cadr exp)           (secl-value (cadr exp) the-locale the-locale t))      (cl-eval-sequence (cddr exp) the-locale))))(defun bind-variables (ids values env)   (cond ((CONSP ids)         (bind-variable (car ids)                        (car values)                        (bind-variables (cdr ids)                                        (cdr values)                                        env)))        ((NULL ids) env)        (else         (bind-variable ids values env))))(defun bind-variable (identifier value env)   (object nil          ((cl-env-lookup self id local? create?)           (cond ((EQ  id identifier)                  (locative value))                 (else                  (cl-env-lookup env id local? create?))))))(defun value (id env)   (contents (cl-env-lookup env id nil nil)))(defun secl-value (id env val local?)   (SETF (contents (cl-env-lookup env id local? t)) val))(defun cl-eval-lambda (exp env)  #'(lambda args      (cl-eval-sequence (cddr exp)                        (bind-variables (cadr exp) args env))))(defun cl-eval-set (exp env)   (let ((place (cadr exp)))    (cond      ((atom place)      (secl-value place env (cl-eval (caddr exp) env) nil))     (else      (cl-eval `((setter ,(car place)) ,@(cdr place) ,(caddr exp))               env)))))(defun cl-eval-lset (exp env)  (secl-value (cadr exp) env (cl-eval (caddr exp) env) t))(defun cl-eval-define (exp env)    (let ((pattern (cadr exp)))    (cond ((ATOM pattern)           (cl-eval-lset exp env))          (else           (cl-eval-lset            `(lset ,(car pattern)                   #'(lambda ,(cdr pattern) ,@(cddr exp)))            env)))))(defun cl-eval-object (exp env)   (cl-eval-objeccl-aux (cl-eval (cadr exp) env) (cddr exp) env))(defun cl-eval-objeccl-aux (proc clauses env)   (cond    ((NULL clauses)    (object proc))   (else    (let ((clause (car clauses)))      (join (object proc                    (((cl-eval (caar clause) env) self . args)                     (cl-eval-sequence (cdr clause)                                       (bind-variables (cdar clause)                                                       (cons self args)                                                       env))))            (cl-eval-objeccl-aux nil (cdr clauses) env))))))