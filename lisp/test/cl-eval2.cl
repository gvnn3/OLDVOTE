;; no setf -- use setq instead;; defun -- recursive functions?;; let -- ??;; allocate local variables above global value;; make functions evaluate to themselves?(defun cl-eval (exp env)    (cond ((or (numberp exp)             (functionp exp)             (characterp exp)             (stringp exp))         exp)        ((symbolp exp)         (value exp env))        ((consp exp)         (case (car exp)           ((quote)    (cadr exp))           ((if)       (cl-eval-if       exp env))           ((progn)    (cl-eval-progn    exp env))           ((lambda)   (cl-eval-lambda   exp env))           ((defun)    (cl-eval-defun    exp env))           ((setq)     (cl-eval-setq     exp env))           ((case)     (cl-eval-case     exp env))           ((cond)     (cl-eval-cond     exp env))           ((and)      (cl-eval-and      exp env))           ((or)       (cl-eval-or       exp env))           ((let)      (cl-eval-let      exp env))           (otherwise  (cl-eval-call     exp env))))))(defun cl-eval-call (exp env)   (let* ((func (cl-eval (car exp) env))         (func2 (if (and (consp func) (eq 'lambda (car func)))                  (cl-eval-lambda func env)                  func)))    (apply func2           (mapcar #'(lambda (arg) (cl-eval arg env))                   (cdr exp)))))(defun old-cl-eval-call (exp env)   (apply (cl-eval (car exp) env)         (mapcar #'(lambda (arg) (cl-eval arg env))                 (cdr exp))));; OK(defun cl-eval-if (exp env)  (if (cl-eval (cadr exp) env)      (cl-eval (caddr exp) env)      (cl-eval (cadddr exp) env)));; OK(defun cl-eval-progn (exp env)   (cl-eval-sequence (cdr exp) env));; OK(defun cl-eval-sequence (exps env)   (cond ((null (cdr exps))         (cl-eval (car exps) env))        (else         (cl-eval (car exps) env)         (cl-eval-sequence (cdr exps) env))))(defun bind-variables (ids values env)   (cond ((consp ids)         (bind-variable (car ids)                        (car values)                        (bind-variables (cdr ids)                                        (cdr values)                                        env)))        ((null ids) env)        (else         (bind-variable ids values env))));; OK?(defun bind-variable (identifier value env)   (make-environment identifier value env t));; OK?(defun value (id env)   (let ((result (cl-env-lookup env id nil nil)))    (cond (result (env-contents result))          (else (env-contents id)))));; OK?(defun set-value (id env val local?)   (setf (env-contents (cl-env-lookup env id local? t)) val))(defun cl-eval-lambda (exp env)  #'(lambda (&rest args)      (cl-eval-sequence (cddr exp)                        (bind-variables (cadr exp) args env))))(defun cl-eval-setq (exp env)   (let ((place (cadr exp)))    (set-value place env (cl-eval (caddr exp) env) nil)));; problem with recursive or non-recursive calls;; =============================================(defun cl-eval-defun (exp env)    (let ((name (cadr exp)))    (set-value name env               `(lambda ,(caddr exp) ,@(cdddr exp)) nil)));;; ************ exercises(defun cl-eval-cond (exp env)      (cl-eval-cond-aux (cdr exp) env))(defun cl-eval-cond-aux (exp env)      (cond ((cl-eval (caar exp) env)           (cl-eval-sequence (cdar exp) env))          (else           (cl-eval-cond-aux (cdr exp) env))))(defun cl-eval-case (exp env)      (cl-eval-case-aux            (cl-eval (cadr exp) env)            (cddr exp)            env))(defun cl-eval-case-aux (key clauses env)      (cond ((null clauses) nil)          ((or (eq 'otherwise (caar clauses))               (member key (caar clauses)))           (cl-eval-sequence (cdar clauses) env))          (else           (cl-eval-case-aux key (cdr clauses) env))))(defun cl-eval-and (exp env)      (cl-eval-and-aux (cdr exp) env))(defun cl-eval-and-aux (exp env)      (if (null (cdr exp))         (cl-eval (car exp) env)        (if (cl-eval (car exp) env)            (cl-eval-and-aux (cdr exp) env)            nil)))(defun cl-eval-or (exp env)      (cl-eval-or-aux (cdr exp) env))(defun cl-eval-or-aux (exp env)      (cond ((null exp) nil)          ((cl-eval (car exp) env))          (else           (cl-eval-or-aux (cdr exp) env))));; OK(defun cl-eval-let (exp env)    (apply     #'(lambda (&rest args)      (cl-eval-sequence (cddr exp)           (bind-variables (mapcar #'car (cadr exp))                           args env)))    (mapcar #'cadr (cadr exp))));;; ************ exercises(defclass environment ()  ((id :initarg :id :reader env-id)   (contents  :initarg :contents :accessor env-contents)   (next :initarg :next :accessor env-next))  (:documentation "A simple environment class"))  (defun make-environment (id val env local?)  (let ((new (make-instance 'environment :id id :contents val :next nil)))    (cond ((and env (not local?))           (setf (env-next new) (env-next env))           (setf (env-next env) new))          ((and env local?)           (setf (env-next new) env)))    new))(defmethod print-object ((env environment) (str stream))  (format str "~%~A:~10T~A" (env-id env) (env-contents env))  (if (env-next env) (print-object (env-next env) str))  (values))(defmethod cl-env-lookup ((env environment) id local? create?)  (cond ((eq (env-id env) id) env)        ((env-next env)         (cl-env-lookup (env-next env) id local? create?))        (create?         (make-environment id nil env local?))        (else nil)))(defmethod cl-env-lookup (env id local? create?)  id)(defmethod env-contents (obj)  (cond ((fboundp obj) (symbol-function obj))        ((functionp obj) obj)        ((boundp obj)  (symbol-value obj))        (else obj)))